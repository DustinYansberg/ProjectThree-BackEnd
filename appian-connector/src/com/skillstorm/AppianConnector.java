package com.skillstorm;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Iterator;
import java.util.Map;

import com.fasterxml.jackson.databind.ObjectMapper;

import openconnector.AbstractConnector;
import openconnector.ConnectorException;
import openconnector.Filter;



/**
 * All we need this class to do is
 * 1. Pull an aggregate of accounts (users) from Appian
 * 2. Update user entitlements (groups)
 * 
 * Users are just two strings - id:name
 * Groups are just an array of strings
 * 
 * 
 * Workflow is as follows:
 * 1. Get all users - store
 * 2. Get all groups - store
 * 3. Get all users by each individual group 
 * 		- Iterate through the groups array, then pull users by group for each iteration
 * 		- Since all users are unique, overwrite any user instances with an object { "id":"name", "group":"group-name" }
 * 4. Structure remaining data as needed (add a blank group if SailPoint requires that)
 */

public class AppianConnector extends AbstractConnector
{
	
	/*
	The below values will be obtained from our xhtml file that the admin fills out
	This will obtain values from SailPoint via our configure method

	We fill authString with our access token
	the access token is generated by our Access Token URL
	We get it here in our config method, which will pull it from our form input
	The config method will then make a call the the URL and use the token generated 
	*/

	//"Bearer " + tokenValue; for Oauth2.0 headers
	private String host; //base url for API calls
	private String authString; //this will be generated BY the below URL, so we'll set it in each method when a request is made 
	private String tokenUrl;
	private String clientId;
	private String clientSecret;

	/*
		This method is called at initialization
		it sets all values for use in advance
	 */
	public void configure() throws MalformedURLException
	{
		host = config.getConfig().get("host").toString();					//from a value called "host" in our xhtml
		tokenUrl = config.getConfig().get("tokenUrl").toString();			//from a value called "tokenUrl" in our xhtml
		clientId = config.getConfig().get("clientId").toString();			//from a value "clientId" in our xhtml
		clientSecret = config.getConfig().get("clientSecret").toString();	//from a value "clientSecret" in our xhtml
			//Could have the token refresh called here
			//We'll just make a method that makes the post request to the oauth2 endpoint provided in the appian document, then save the result to our authString
	}



			//for making the auth token - is it a post request?
			// URL authUrl = new URL(tokenUrl);
			// HttpURLConnection authConnection = (HttpURLConnection) authUrl.openConnection();
	
	

	/**
	 * Test connection method 
	 * returns void
	 * throws ConnectorException
	 * 
	 * - This method will be used by the IIQ instance to determine whether the app is successfully connected
	 *	No functionality for this method beyond confirming a connection
	 * 	 
	 */
	@Override
	public void testConnection() throws ConnectorException
	{
		try 
		{
		
			configure();
			

			URL url = new URL(host + "/get-groups");
			HttpURLConnection connection = (HttpURLConnection) url.openConnection(); //must be cast to a more specific URL type
			
			connection.setRequestMethod("GET");
			connection.setRequestProperty("Authorization", authString); //this appends "Authorization: " before "Bearer "
			int responseCode = connection.getResponseCode();
			if(responseCode != 200)
				throw new IOException("Could not connect: " + connection.getResponseMessage());	//printing out message for response
			else 
			{
				//reading the contents of the connection - using the connection as an input stream so we can do something with it
				//NOTE this section is mostly just for debugging purposes so we can see something in the console
				BufferedReader reader = new BufferedReader( new InputStreamReader(connection.getInputStream()));
				StringBuffer sb = new StringBuffer();
				sb.append("Response Code: " + responseCode + ", Content: ");

				String currentLine;

				while((currentLine = reader.readLine()) != null) 
				{
					sb.append(currentLine);
				}

				System.out.println(sb.toString());

				reader.close();
			}
		} 
		catch(IOException e)
		{
			throw new ConnectorException(e.getMessage());	//this fails the test in SailPoint - SailPoint will fail test if it gets a Connector Exception
		}
	}

	/**
	 * Iterate method
	 * returns an Iterator containing Maps with a String key and Object value
	 * throws ConnectorException and UnsupportedOperationException
	 * 
	 * - This method iterates through the connected application's accounts and then returns them to SailPoint
	 * - Called when Aggregate Accounts task is used in SailPoint
	 */
	@Override
	public Iterator<Map<String, Object>> iterate(Filter filter) throws ConnectorException, UnsupportedOperationException
	{
		try
		{	
			configure();	//will set auth string
			
			//this section gets the accounts (appian users)
			URL url = new URL(host + "/get-all-users");
			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
			connection.setRequestMethod("GET");
			connection.setRequestProperty("Authorization", authString);

			if(connection.getResponseCode() != 200)
				throw new IOException("Response code was not 200!");
			else
			{
				//reader defined, taking input via inputstream which it gets from our connection
				BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));	
				//using stringbuffer for mutability
				StringBuffer sb = new StringBuffer();
				//to be taken in from our reader and then appended to our string buffer
				String currentLine;

				//reading line by line...
				while((currentLine = reader.readLine()) != null)
				{
					//and appending to our string buffer
					sb.append(currentLine);
				}

				//print to tomcat's console
				String response = sb.toString();
				System.out.println(response);

				//ObjectMapper is used to pull out the JSON objects from the response string
				ObjectMapper mapper = new ObjectMapper();

pick up here		//
			}
		}
		catch (IOException e)
		{
			throw new ConnectorException(e.getMessage());
		}
		return null;
	}


	/**
	 * Create method
	 * 
	 * - This method creates a user account in the connected system
	 * 
	 * This is not needed. We cannot create users in the connected system due to a lack of endpoints.
	 */

	
	/**
	 * Read method
	 * 
	 * - This method gets a specific account from the connected system
	 * 
	 * Not sure if we even need this since we're only going to get all accounts
	 */
	@Override
	public Map<String, Object> read(String arg)
	{
		return null;
	}
	
}
