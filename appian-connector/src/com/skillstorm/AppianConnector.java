package com.skillstorm;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Base64;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import openconnector.AbstractConnector;
import openconnector.ConnectorException;
import openconnector.Filter;
import openconnector.Item;
import openconnector.Result;



/**
 * All we need this class to do is
 * 1. Pull an aggregate of accounts (users) from Appian
 * 2. Update user entitlements (groups)
 * 
 * Users are just two strings - id:name
 * Groups are just an array of strings
 * 
 * 
 * Workflow is as follows:
 * 1. Get all users - store
 * 2. Get all groups - store
 * 3. Get all users by each individual group 
 * 		- Iterate through the groups array, then pull users by group for each iteration
 * 		- Since all users are unique, overwrite any user instances with an object { "id":"name", "group":"group-name" }
 * 4. Structure remaining data as needed (add a blank group if SailPoint requires that)
 */

public class AppianConnector extends AbstractConnector
{
	
	/*
	The below values will be obtained from our xhtml file that the admin fills out
	This will obtain values from SailPoint via our configure method

	We fill authString with our access token
	the access token is generated by our Access Token URL
	We get it here in our config method, which will pull it from our form input
	The config method will then make a call the the URL and use the token generated 
	*/

	//Input from xhtml form
	private String host; 			//base url for API calls 
	private String oauthUrl;		//url input to get the oauth token
	private String clientId;		//client id needed to get oauth token
	private String clientSecret;	//client secret needed to get oauth token
	
	//Generated by POST to oauthUrl
	private String authString; 		//this will be generated once we make a post request to the oauth url

	/*
	This method is called at the start of each method call
	it sets all values for use in advance
	 */
	public void configure() throws MalformedURLException, ConnectorException
	{
		//NOTE: config is a variable inherited from the AbstractConnector class
		// it is a ConnectorConfig instance
		host = config.getConfig().get("host").toString();					//from a value called "host" in our xhtml
		oauthUrl = config.getConfig().get("oauthUrl").toString();			//from a value called "oauthUrl" in our xhtml
		clientId = config.getConfig().get("clientId").toString();			//from a value "clientId" in our xhtml
		clientSecret = config.getConfig().get("clientSecret").toString();	//from a value "clientSecret" in our xhtml
	
		
		//This sets authString [ DOES NOT GET FROM THE XHTML FORM - SO WE'RE GOOD HERE ]
		try 
		{
			//this endpoint uses basic auth to make the req. the input clientId and clientSecret are the username and password
			String tokenAuth = "Basic " +  Base64.getEncoder().encodeToString((clientId + ":" + clientSecret).getBytes()); 
			//now we append the query to our oauthUrl (always grant_type=client_credentials)
			URL authUrl = new URL(oauthUrl + "?grant_type=client_credentials");		
			//cast to HttpURLConnection to establish our connection
			HttpURLConnection authConnection = (HttpURLConnection) authUrl.openConnection();
			//Make the post request and append the request headers
			authConnection.setRequestMethod("POST");
			authConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
			authConnection.setRequestProperty("Authorization", tokenAuth);	//this does not overwrite the prior one
			
			//This will contain our response that we'll then put into our authString
			StringBuffer response;
			int responseCode = authConnection.getResponseCode();	//get response
			if (responseCode == HttpURLConnection.HTTP_OK) 			//compare against 200. If 200 do the below
			{
				/*
				Because we opened the connection above (line 86) we are able to read from the stream of data
				We're putting that into this buffered reader, which reads from a character input stream

				Basically, we're creating an input stream, pulling out an input stream from authConnection,
				which is a connection that was previously opened, and then we're putting it into a reader
				to then append those characters into our response - declared above (line 93)
				 */
				BufferedReader in = new BufferedReader(new InputStreamReader(authConnection.getInputStream()));
				response = new StringBuffer();
				String line;	//placeholder for wherever we're at in the data stream
				while ((line = in.readLine()) != null) //so long as we can read a line...
				{
					response.append(line);	//append it to our response
				}
				in.close();	//and once we can't, close the reader
		
				// Parse JSON response to get the access token
				ObjectMapper mapper = new ObjectMapper();
				//pull out everything from response and then put it into a map of string, object
				//we can then parse it (the response will always contain "access_token" somewhere)
				//get the result and append it to our auth string. 
				Map<String, Object> responseMap = mapper.readValue(response.toString(), new TypeReference<Map<String, Object>>(){});
				authString = "Bearer " + responseMap.get("access_token").toString();

				
			} 
			else 
			{
				throw new IOException("Failed to obtain access token: " + authConnection.getResponseMessage());
			}
		}
		catch(IOException e)
		{
			throw new ConnectorException(e.getMessage());
		}
	}

	

	/**
	 * Test connection method 
	 * returns void
	 * throws ConnectorException
	 * 
	 * - This method will be used by the IIQ instance to determine whether the app is successfully connected
	 *	No functionality for this method beyond confirming a connection
	 * 	 
	 */
	@Override
	public void testConnection() throws ConnectorException
	{
		try 
		{
		
			configure();
			

			URL url = new URL(host + "/suite/webapi/get-groups");
			HttpURLConnection connection = (HttpURLConnection) url.openConnection(); //must be cast to a more specific URL type
			
			connection.setRequestMethod("GET");
			connection.setRequestProperty("Authorization", authString); //this appends "Authorization: " before "Bearer "
			int responseCode = connection.getResponseCode();
			if(responseCode != 200)
				throw new IOException("Could not connect: " + connection.getResponseMessage());	//printing out message for response
			else 
			{
				//reading the contents of the connection - using the connection as an input stream so we can do something with it
				//NOTE this section is mostly just for debugging purposes so we can see something in the console
				BufferedReader reader = new BufferedReader( new InputStreamReader(connection.getInputStream()));
				StringBuffer sb = new StringBuffer();
				sb.append("Response Code: " + responseCode + ", Content: ");

				String currentLine;

				while((currentLine = reader.readLine()) != null) 
				{
					sb.append(currentLine);
				}

				// System.out.println(sb.toString());

				reader.close();
			}
		} 
		catch(IOException e)
		{
			throw new ConnectorException(e.getMessage());	//this fails the test in SailPoint - SailPoint will fail test if it gets a Connector Exception
		}
	}

	/**
	 * Iterate method
	 * returns an Iterator containing Maps with a String key and Object value
	 * throws ConnectorException and UnsupportedOperationException
	 * 
	 * - This method iterates through the connected application's accounts and then returns them to SailPoint
	 * - Called when Aggregate Accounts task is used in SailPoint
	 */
	@Override
	public Iterator<Map<String, Object>> iterate(Filter filter) throws ConnectorException, UnsupportedOperationException
	{	
		/**
		 * Workflow is as follows:
	O	 * 1. Get all users - store 
	O	 * 2. Get all groups - store
	O	 * 3. Get all users by each individual group 
	(i)	 * 		- Iterate through the groups array, then pull users by group for each iteration
	(i)	 * 		- Since all users are unique, overwrite any user instances with an object { "id":"name", "group":"group-name" }
		 * 4. Structure remaining data as needed (add a blank group if SailPoint requires that)
		 */

		//"id"
		//create "entitlements"
		/**
		 * THE FINAL OBJECT MUST MATCH WHATEVER IS IN OUR appian-connector-registry.xml FILE
		 *  Names are "id" and "entitlement"
		 * 
		 * 
		 */
		//each user is always "id" paired with "(name)" so each is Map<"id","(name)">
		
		List<Map<String, Object>> users = getAllUsers();
		for(Map<String, Object> user : users )
		{
			user.put("entitlement", new LinkedList<String>());	
		}
	
		List<String> entitlements = getAllEntitlements();
		System.out.println("Got entitlements");
		System.out.println(entitlements.toString());
		
		for(String entitlement : entitlements)
		// for(int i = 0 ; i < entitlements.size(); i++)
		{
			// String entitlement = entitlements.get(i);
			List<Map<String, Object>> usersByEntitlement = getAllUsersByEntitlement(entitlement);

			if(usersByEntitlement.size() > 0)
			{
				for(Map<String, Object> userEnt : usersByEntitlement)	//here we have a series of users that are {"id":"name"}
				{
					//let's make them all {"id":"name", "entitlement":["group1","group2",..]}
					for(Map<String, Object> user : users)
					{
						if(user.get("id").equals(userEnt.get("id")))
						{
							
							List<String> userEntitlements = (List<String>) user.get("entitlement");
							
							if(!userEntitlements.contains(entitlement))
							{
								userEntitlements.add(entitlement);
								
								user.put("entitlement", userEntitlements);
								
							}
							
						}
						
					}
					
					


				}
				
			}
			
		}
		
		return users.iterator();


	}


	/**
	 * update()
	 * 
	 * get sailpoint object
	 * get groups
	 * compare to groups
	 * for any groups it does have, add that group
	 * any groups it does not have, remove that group
	 * 
	 * return sailpoint object
	 * @throws ConnectorException 
	 */
/* 
	@Override
	public Result update(String id, List<Item> items) throws ConnectorException
	{
		try 
		{
			configure();
		
			//create object to hold payload
			Map<String, Object> payload = new HashMap<>();

			for(Item item : items)
			{
				payload.put(item.getName(), item.getValue());
			}
			payload.put("usernames", "[" + id + "]");
			System.out.println(payload.toString());
		}
		catch(IOException e)
		{
			throw new ConnectorException(e.getMessage());
		}
		return null;
	}
*/
	 
	/**
	 * Read method 
	 * (AbstractConnector requires that we have this here)
	 * 
	 * - This method gets a specific account from the connected system
	 * 
	 * Not sure if we even need this since we're only going to get all accounts
	 */
	@Override
	public Map<String, Object> read(String arg)
	{
		return null;
	}


	//HELPER method to get all users
	//this brings back an iterator of Map<String, String> because every object returned is {"id":"(name)"}
	//All we really need to return is the (name) - This can be handled elsewhere

	//NOTE THAT THIS RETURNS THE FOLLOWING [ { "id":"(name)" }, ... ]
	//We don't need "id" 
	public List<Map<String, Object>> getAllUsers() throws ConnectorException 
	{
		try 
		{
			configure(); 
			System.out.println("getAllUsers config method successful");
			URL url = new URL(host + "/suite/webapi/get-all-users");
			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
			connection.setRequestMethod("GET");
			connection.setRequestProperty("Authorization", authString);
			
			if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) 
			{
				throw new IOException("Failed to get groups: " + connection.getResponseMessage());
			}
	
			BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
			StringBuffer sb = new StringBuffer();
			String currentLine;
			
			while ((currentLine = reader.readLine()) != null) 
			{
				System.out.println("Appending to StringBuffer");
				sb.append(currentLine);
			}
			reader.close();
			
			String response = sb.toString();
			
			ObjectMapper mapper = new ObjectMapper();
			List<Map<String, Object>> users = mapper.readValue(response, new TypeReference<List<Map<String,Object>>>(){});
			
			System.out.println("Returning users");
			return users;
			
		} 
		catch (IOException e) 
		{
			throw new ConnectorException("Error retrieving groups: " + e.getMessage());
		}
	}


	//HELPER method to get all groups
	//this brings back an Iterator of Strings because this endpoint ONLY has an array of strings in it ever

	//NOTE: This ONLY returns [ "(name)", ...]
	public List<String> getAllEntitlements() throws ConnectorException 
	{
		try 
		{
			configure(); 
			
			URL url = new URL(host + "/suite/webapi/get-groups");
			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
			connection.setRequestMethod("GET");
			connection.setRequestProperty("Authorization", authString);
			
			if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) 
			{
				throw new IOException("Failed to get groups: " + connection.getResponseMessage());
			}
	
			BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
			StringBuffer sb = new StringBuffer();
			String currentLine;
			
			while ((currentLine = reader.readLine()) != null) 
			{
				sb.append(currentLine);
			}
			reader.close();
	
			String response = sb.toString();
			//get-groups ALWAYS returns an array of Strings - we can just return a list of strings here instead
			ObjectMapper mapper = new ObjectMapper();
			List<String> groups = mapper.readValue(response, new TypeReference<List<String>>(){});
			
			return groups;
			
		} 
		catch (IOException e) 
		{
			throw new ConnectorException("Error retrieving groups: " + e.getMessage());
		}
	}
	
	//HELPER method to get users BY group
	public List<Map<String, Object>> getAllUsersByEntitlement(String groupName) throws ConnectorException 
	{
		try 
		{
			configure(); 
			String query = groupName.replace(" ", "+"); //spaces need to be replaced with + for queries
			URL url = new URL(host + "/suite/webapi/get-users-in-group?group=" + query);
			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
			connection.setRequestMethod("GET");
			connection.setRequestProperty("Authorization", authString);
			
			if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) 
			{
				throw new IOException("Failed to get groups: " + connection.getResponseMessage());
			}
	
			BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
			StringBuffer sb = new StringBuffer();
			String currentLine;
			
			while ((currentLine = reader.readLine()) != null) 
			{
				sb.append(currentLine);
			}
			reader.close();
			
			String response = sb.toString();
			
			ObjectMapper mapper = new ObjectMapper();
			List<Map<String, Object>> users = mapper.readValue(response, new TypeReference<List<Map<String,Object>>>(){});
			
			return users;
			
		} 
		catch (IOException e) 
		{
			throw new ConnectorException("Error retrieving groups: " + e.getMessage());
		}
	}


	//HELPER method to add users to a group
	public void addUsersToGroup(List<String> usernames, String groupName) throws ConnectorException 
	{
		try 
		{
			configure(); 
			
			URL url = new URL(host + "/suite/webapi/add-users-to-group");
			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
			connection.setRequestMethod("POST");
			connection.setRequestProperty("Authorization", authString);
			connection.setRequestProperty("Content-Type", "application/json");
			connection.setDoOutput(true);
	
			// Prepare the request body
			Map<String, Object> requestBody = new HashMap<>();
			requestBody.put("usernames", usernames);
			requestBody.put("group", groupName);
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(requestBody);
			connection.getOutputStream().write(jsonString.getBytes());
	
			if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) 
			{
				throw new IOException("Failed to add users to group: " + connection.getResponseMessage());
			}
	
			// handle the response if needed
			BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
			StringBuffer sb = new StringBuffer();
			String currentLine;
			while ((currentLine = reader.readLine()) != null) 
			{
				sb.append(currentLine);
			}
			reader.close();
			System.out.println("Response from add users to group: " + sb.toString());
			
		} 
		catch (IOException e) 
		{
			throw new ConnectorException("Error adding users to group: " + e.getMessage());
		}
	}
	
	//HELPER method to remove users from group
	public void removeUsersFromGroup(List<String> usernames, String groupName) throws ConnectorException 
	{
		try 
		{
			configure(); // Ensure authString is set
			
			URL url = new URL(host + "/suite/webapi/remove-users-from-group");
			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
			connection.setRequestMethod("POST");
			connection.setRequestProperty("Authorization", authString);
			connection.setRequestProperty("Content-Type", "application/json");
			connection.setDoOutput(true);
	
			// Prepare the request body
			Map<String, Object> requestBody = new HashMap<>();
			requestBody.put("usernames", usernames);
			requestBody.put("group", groupName);
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(requestBody);
			connection.getOutputStream().write(jsonString.getBytes());
	
			if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) 
			{
				throw new IOException("Failed to remove users from group: " + connection.getResponseMessage());
			}
	
			// handle the response if needed
			BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
			StringBuffer sb = new StringBuffer();
			String currentLine;
			while ((currentLine = reader.readLine()) != null) 
			{
				sb.append(currentLine);
			}
			reader.close();
			System.out.println("Response from remove users from group: " + sb.toString());
			
		} 
		catch (IOException e) 
		{
			throw new ConnectorException("Error removing users from group: " + e.getMessage());
		}
	}
	
	
	
}
